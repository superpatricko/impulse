PROCEDURE "LAND"."IFRS_R1.LAND.EH::SP_EH_PK_MAP" 
( 	IN job_id NVARCHAR(20), -- used to get the table name 
	IN process_id INTEGER, -- used to only process error records of current SAP DS job
	OUT OP_STATUS NVARCHAR(100), -- used to notify the BODS framework of errors
	OUT OP_ERROR_MESSAGE NVARCHAR(5000)
)   
	LANGUAGE SQLSCRIPT
	SQL SECURITY INVOKER
	AS
BEGIN
 
 	DECLARE LC_ERROR_TEXT 		NVARCHAR(70) DEFAULT 'OUT STATUS IS 1 : INSERT/UPDATE FOR ONE OR MORE RECORD FAILED';
	DECLARE LC_SUCCESS_TEXT 	NVARCHAR(70) DEFAULT 'OUT STATUS IS 0 : INSERT/UPDATE EXECUTION SUCCESSFUL';
	DECLARE LV_TABLE_NAME    			NVARCHAR(50);
	DECLARE LV_USE_HANA_CATALOG_ONLY    TINYINT;
	DECLARE LV_ERROR_FOUND    			TINYINT := 0;
	DECLARE LV_PK_DYNAMIC_QUERY			NVARCHAR(200);
	DECLARE LV_QUERY					NVARCHAR(1000);
	 
	DECLARE CURSOR c_table_index (v_table_name NVARCHAR(50)) FOR SELECT "COLUMN_NAME", "INDEX_POSITION" 
		FROM "_SYS_BIC"."IFRS_R1.LAND.EH/CA_EH_LANDING_TABLE_METADATA" (PLACEHOLDER."$$IP_TABLE_NAME$$" =>:v_table_name)
		WHERE index_position IS NOT NULL
		ORDER BY index_position;
	 
	--- Get the table name from job_id
	BEGIN
		DECLARE EXIT HANDLER FOR SQL_ERROR_CODE 1299 
		BEGIN AUTONOMOUS TRANSACTION
			DECLARE EXIT HANDLER FOR SQL_ERROR_CODE 1299
			BEGIN AUTONOMOUS TRANSACTION
				-- Handle situation where there are no errors in the error table for the process_id
				LV_ERROR_FOUND = 1;
			END;	
			-- Handle situation where the entries are not found in the "LAND"."IFRS_R1.LAND.EH::EH_ERROR_PK_MAP" table
			SELECT TOP 1 SUBSTR_BEFORE(SUBSTR_AFTER("ERROR_RECORD",'"LAND"."'), '"') INTO lv_table_name FROM "LAND"."IFRS_R1.LAND::ETL_ERROR_DATA" WHERE "JOB_ID" = :job_id AND "FILE_TYPE" = 'O';
			LV_USE_HANA_CATALOG_ONLY = 1;
			--lv_table_name := 'IFRS_R1.LAND::TV_PROD_REF_IPTVB_ORD_PKG_CD';				
		END;
		LV_USE_HANA_CATALOG_ONLY = 0;
		SELECT TOP 1 "TABLE_NAME" INTO lv_table_name FROM "LAND"."IFRS_R1.LAND.EH::EH_ERROR_PK_MAP" WHERE "JOB_ID" = :job_id;
	END;

	IF LV_ERROR_FOUND = 1 THEN
		OP_STATUS = LC_SUCCESS_TEXT;
		OP_ERROR_MESSAGE = 'No error was found for JOB_ID ' || :JOB_ID || '. Warning: No customizing entry was found for this JOB_ID in "LAND"."IFRS_R1.LAND.EH::EH_ERROR_PK_MAP". In this case the error capture is not enabled for this table because the primary key is required for this.';
		RETURN;
	END IF;

	IF LV_USE_HANA_CATALOG_ONLY = 0 THEN
		-- Extract the primary key, parent key, and amount from the error record
		-- Fixed width records
		error_fixed_width = SELECT "ROWID",
									STRING_AGG("CC_PRIMARY_KEY", '|' ORDER BY "SEQUENCE_OF_CONCAT" ) AS "PRIMARY_KEY",
									STRING_AGG("CC_PARENT_KEY", '|' ORDER BY "SEQUENCE_OF_CONCAT" ) AS "PARENT_KEY",
									SUM("CC_AMOUNT") AS "AMOUNT" 
							FROM "_SYS_BIC"."IFRS_R1.LAND.EH/CA_EH_CIRLANDING" (PLACEHOLDER."$$IP_TABLE_NAME$$" => :lv_table_name,
															PLACEHOLDER."$$IP_PROCESS_ID$$" => :process_id)
							WHERE SEPARATOR_TYPE = 'F'
							GROUP BY "ROWID", "JOB_ID", "CYCLE_ID", "PROCESS_ID";
		
		-- Delimited records
		/**
			The separation between the Fixed record and delimited record is due to a bug in SAP HANA.
			The delimited records requires the locate function with 4 parameters. This is not available in the 
			calculation view, thus we had to move the logic to the stored procedure.
			
			At the time of the stored procedure development (2017-03-01), the OSS 37918/2017 is unresolved.
		*/	 
		delimited_records = SELECT  "ROWID",
									STRING_AGG("PRIMARY_KEY", '|' ORDER BY "SEQUENCE_OF_CONCAT" ) AS "PRIMARY_KEY",
									STRING_AGG("PARENT_KEY", '|' ORDER BY "SEQUENCE_OF_CONCAT" ) AS "PARENT_KEY",
									SUM("AMOUNT") AS "AMOUNT"
							FROM
							(
								SELECT "JOB_ID",
								"ROWID",
								"CYCLE_ID",
								"PROCESS_ID",
								"SEQUENCE_OF_CONCAT",
								CASE WHEN "SEQUENCE_OF_CONCAT" > 0
								THEN "FIELD_VALUE"
								END AS "PRIMARY_KEY",
								CASE WHEN "IS_PARENT_KEY" = 1
								THEN "FIELD_VALUE"
								END AS "PARENT_KEY",
								CASE WHEN "IS_AMOUNT" = 1
								THEN TO_INTEGER("FIELD_VALUE")
								END AS "AMOUNT"
								FROM 
								(	SELECT
										 "JOB_ID",
										 "ROWID",
										 "CYCLE_ID",
										 "PROCESS_ID",
										 "FILE_TYPE",
										 "ERROR_RECORD",
										 "TABLE_NAME",
										 "FIELD_NAME",
										 "IS_PRIMARY_KEY",
										 "IS_PARENT_KEY",
										 "IS_AMOUNT",
										 "SEPARATOR_TYPE",
										 "START_POSITION",
										 "END_POSITION",
										 "SEPARATOR",
										 "SEPARATOR_POSITION",
										 "SEQUENCE_OF_CONCAT",
										 TRIM(REPLACE(SUBSTRING("ERROR_RECORD",LOCATE("ERROR_RECORD",',',0,"SEPARATOR_POSITION")+1, LOCATE("ERROR_RECORD",',',0,"SEPARATOR_POSITION"+1) - LOCATE("ERROR_RECORD",',',0,"SEPARATOR_POSITION") -1),'''','')) AS "FIELD_VALUE",
										 "AGING_LIMIT" 
									FROM "_SYS_BIC"."IFRS_R1.LAND.EH/CA_EH_CIRLANDING" (PLACEHOLDER."$$IP_TABLE_NAME$$" => :LV_TABLE_NAME,
																						PLACEHOLDER."$$IP_PROCESS_ID$$" => :process_id)
										 WHERE SEPARATOR_TYPE != 'F'
										 ORDER BY "SEQUENCE_OF_CONCAT" ASC NULLS LAST
								)
							) GROUP BY 	"ROWID";
		all_records = SELECT * FROM :delimited_records UNION SELECT * FROM :error_fixed_width;
	ELSE
		hana_catalog_only_records = SELECT  "ROWID",
									STRING_AGG("PRIMARY_KEY", '|' ORDER BY "SEQUENCE_OF_CONCAT" ) AS "PRIMARY_KEY",
									'' "PARENT_KEY",
									0 AS "AMOUNT"
									FROM
									(
											SELECT
												 "JOB_ID",
												 "ROWID",
												 "ERROR_RECORD",
												 "TABLE_NAME",
												 "FIELD_NAME",
												 "SEQUENCE_OF_CONCAT",
												 TRIM(REPLACE(SUBSTRING("ERROR_RECORD",LOCATE("ERROR_RECORD",',',0,"SEPARATOR_POSITION")+1, LOCATE("ERROR_RECORD",',',0,"SEPARATOR_POSITION"+1) - LOCATE("ERROR_RECORD",',',0,"SEPARATOR_POSITION") -1),'''','')) AS "PRIMARY_KEY",
												 '' AS "PARENT_KEY"									 
											FROM "_SYS_BIC"."IFRS_R1.LAND.EH/CA_EH_PK_MAP" (PLACEHOLDER."$$IP_TABLE_NAME$$" => :LV_TABLE_NAME,
																								PLACEHOLDER."$$IP_PROCESS_ID$$" => :PROCESS_ID)
												 ORDER BY "SEQUENCE_OF_CONCAT" ASC NULLS LAST
									) GROUP BY 	"ROWID";
		all_records = SELECT * FROM :hana_catalog_only_records;							
	END IF;
	
	ERRORS_OF_CURRENT_PROCESS_ID = SELECT TOP 1 "PROCESS_ID" FROM "LAND"."IFRS_R1.LAND::ETL_ERROR_DATA" WHERE "PROCESS_ID" = :process_id;
	-- :all_records can be empty even if process_id has error records since it joins with PK tables. If this happens, no PK has been defined for table
	IF IS_EMPTY(:all_records) AND NOT IS_EMPTY(:ERRORS_OF_CURRENT_PROCESS_ID) THEN
		OP_STATUS = LC_ERROR_TEXT;
		OP_ERROR_MESSAGE = 'There is no primary key defined in the HANA Catalog or in "LAND"."IFRS_R1.LAND.EH::EH_ERROR_PK_MAP" for table. In this case the error capture is not enabled for this table because the primary key is required for this.';
	ELSEIF NOT IS_EMPTY(:all_records) THEN
		-- Update the error table with the new data
		UPDATE "LAND"."IFRS_R1.LAND::ETL_ERROR_DATA" 
			SET "LAND"."IFRS_R1.LAND::ETL_ERROR_DATA"."PRIMARY_KEY" = :all_records."PRIMARY_KEY",
				"LAND"."IFRS_R1.LAND::ETL_ERROR_DATA"."PARENT_KEY" = :all_records."PARENT_KEY",
				"LAND"."IFRS_R1.LAND::ETL_ERROR_DATA"."AMOUNT" = :all_records."AMOUNT" 
			FROM "LAND"."IFRS_R1.LAND::ETL_ERROR_DATA", :all_records 
			WHERE "LAND"."IFRS_R1.LAND::ETL_ERROR_DATA"."$rowid$" = :all_records."ROWID";	
		OP_STATUS = LC_SUCCESS_TEXT;
	ELSE
		OP_STATUS = LC_SUCCESS_TEXT;
		OP_ERROR_MESSAGE = 'There was no records found for this process id.';		
	END IF;
	
	BEGIN
		DECLARE EXIT HANDLER FOR SQLEXCEPTION
		BEGIN AUTONOMOUS TRANSACTION
			-- Handle situation where there are no errors in the error table for the process_id
			OP_STATUS = LC_ERROR_TEXT;
			OP_ERROR_MESSAGE = 'There was an error during the flag to delete process of this procedure';
		END;	
		-- Check the landing table with the error table, delete from processed error table if key found in landing
		--- Loop through the primary keys of the table to form the primary key pk1|pk2|pk3
		FOR cur_row AS c_table_index(:lv_table_name) DO
			IF LV_PK_DYNAMIC_QUERY IS NULL THEN
				LV_PK_DYNAMIC_QUERY = cur_row.column_name;
			ELSE
				LV_PK_DYNAMIC_QUERY = :LV_PK_DYNAMIC_QUERY || '||''|''||' || cur_row.column_name;
			END IF;
		END FOR;
		-- Only execute if we can form a primary key
		IF LV_PK_DYNAMIC_QUERY IS NOT NULL THEN
			--- Form the query, we insert into a temp table because dynamic SQL does not have any returning parameters
			lv_query = 'insert into "LAND"."IFRS_R1.LAND.EH::EH_TEMP_ERROR_LAND_CHECK" select a.PRIMARY_KEY, a."$rowid$" from "LAND"."IFRS_R1.LAND::ETL_ERROR_DATA" as a inner join "LAND"."'|| :lv_table_name || '" on primary_key = ' || :lv_pk_dynamic_query;
			EXEC :lv_query;
		
			-- EH_TEMP_ERROR_LAND_CHECK is a global temporary table, so data in the table is specific per session
			fixed_records = SELECT * FROM "LAND"."IFRS_R1.LAND.EH::EH_TEMP_ERROR_LAND_CHECK";
			 
			UPDATE "LAND"."IFRS_R1.LAND::ETL_ERROR_DATA" 
				SET "LAND"."IFRS_R1.LAND::ETL_ERROR_DATA"."DELETE_DATE" = CURRENT_DATE 
				FROM "LAND"."IFRS_R1.LAND::ETL_ERROR_DATA", :fixed_records 
				WHERE "LAND"."IFRS_R1.LAND::ETL_ERROR_DATA"."$rowid$" = :fixed_records."ROWID"
					AND "DELETE_DATE" IS NULL;
		ELSE
			OP_STATUS = LC_ERROR_TEXT;
			OP_ERROR_MESSAGE = 'There is no primary key defined in the HANA Catalog or in "LAND"."IFRS_R1.LAND.EH::EH_ERROR_PK_MAP" for table. In this case the error capture is not enabled for this table because the primary key is required for this.';		
		END IF;
	END;	 
END;